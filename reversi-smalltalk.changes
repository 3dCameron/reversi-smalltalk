----QUIT----2019-11-03T09:30:59.192054+01:00 Pharo8.0-SNAPSHOT-32bit-2de6317.image priorSource: 0!----QUIT----2019-11-03T09:31:22.333923+01:00 Pharo8.0-SNAPSHOT-32bit-2de6317.image priorSource: 0!Object subclass: #ReversiGame	instanceVariableNames: 'turn state bScore wScore legalMoves'	classVariableNames: ''	package: 'Reversi'!Object subclass: #ReversiBoard	instanceVariableNames: 'a b c d e f g h'	classVariableNames: ''	package: 'Reversi'!ReversiBoard subclass: #ReversiCell instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Reversi'!Object subclass: #ReversiGame	instanceVariableNames: 'board turn state bScore wScore legalMoves'	classVariableNames: ''	package: 'Reversi'!ReversiBoard subclass: #ReversiCell	instanceVariableNames: 'east northeast north northwest west southwest south southeast state'	classVariableNames: ''	package: 'Reversi'!ReversiBoard subclass: #ReversiCell	instanceVariableNames: 'neighbors state'	classVariableNames: ''	package: 'Reversi'!!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:00'!initialize			board := ReversiBoard new.! !Object subclass: #ReversiBoard	"Stores and tracks an 8x8 board of ReversiCell objects"	instanceVariableNames: 'a b c d e f g h'	classVariableNames: ''	package: 'Reversi'!ReversiBoard subclass: #ReversiCell	"A single cell of the Reversi board."	instanceVariableNames: 'neighbors state'	classVariableNames: ''	package: 'Reversi'!Object subclass: #ReversiBoard	"Stores and tracks an 8x8 grid of cells for Reversi."	instanceVariableNames: 'a b c d e f g h'	classVariableNames: ''	package: 'Reversi'!ReversiBoard class	"Stores and tracks an 8x8 grid of cells for Reversi."	instanceVariableNames: ''!!ReversiBoard commentStamp: 'CameronBierwagen 11/3/2019 19:11' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  Stores and tracks an 8x8 grid of cells for Reversi.For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	a:		<Array>	b:		<Array>	c:		<Array>	d:		<Array>	e:		<Array>	f:		<Array>	g:		<Array>	h:		<Array>    Implementation Points!!ReversiBoard commentStamp: 'CameronBierwagen 11/3/2019 19:12' prior: 33556275!Stores and tracks an 8x8 grid of cells for Reversi.    Instance Variables	a:		<Array>	b:		<Array>	c:		<Array>	d:		<Array>	e:		<Array>	f:		<Array>	g:		<Array>	h:		<Array>!!ReversiBoard commentStamp: 'CameronBierwagen 11/3/2019 19:15' prior: 33557107!Stores and tracks an 8x8 grid of cells for Reversi.    Instance Variables	cells: <Array2D>!Object subclass: #ReversiBoard	instanceVariableNames: 'cells'	classVariableNames: ''	package: 'Reversi'!!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:24'!initialize	cells := Array2D new: 8; atAllPut: ReversiCell new.		! !!EyeInspector methodsFor: 'event-handling' stamp: 'AutoDeprecationRefactoring 11/3/2019 19:27' prior: 24135189!updateList	"update the list of elements displayed according to the new object"	| elements |	"	self haltOnce."	elements := self generateElements.	self list items = elements		ifTrue: [ ^ self ].	"first reset the items to make sure we don't interfere with the display block"	"self list items: #()."	self list display: [ :eyeElement | self labelFor: eyeElement ].	self list items: elements.	"handle when last item of list is removed"	self list selection selectedIndex > self list items size		ifTrue: [ self list setSelectedIndex: self list listItems size ].	"handle when selected dictionary key is removed"	self list selectIndex: self list selection selectedIndex.	self list menu: [ :aMenu | self inspectionMenu: aMenu ]! !!ReversiCell methodsFor: 'initialize' stamp: 'CameronBierwagen 11/3/2019 19:39'!initialize	state := $_.	neighbors := Array new: 8.! !!ReversiCell methodsFor: 'initialize' stamp: 'CameronBierwagen 11/3/2019 19:40' prior: 33558656!initialize	super initialize.	state := $_.	neighbors := Array new: 8.! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:40' prior: 33557653!initialize	super initialize.	cells := Array2D new: 8; atAllPut: ReversiCell new.		! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:43' prior: 33558981!initialize	super initialize.	cells := Array2D new: 8.	cells atAllPut: ReversiCell new.		! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:55'!initialize			board := ReversiBoard new.! !!EyeInspector methodsFor: 'event-handling' stamp: 'CameronBierwagen 11/3/2019 19:55' prior: 24135189!updateList	"update the list of elements displayed according to the new object"	| elements |	"	self haltOnce."	elements := self generateElements.	self list items = elements		ifTrue: [ ^ self ].	"first reset the items to make sure we don't interfere with the display block"	"self list items: #()."	self list display: [ :eyeElement | self labelFor: eyeElement ].	self list items: elements.	"handle when last item of list is removed"	self list selection selectedIndex > self list items size		ifTrue: [ self list setSelectedIndex: self list listItems size ].	"handle when selected dictionary key is removed"	self list selectIndex: self list selection selectedIndex.	self list menu: [ :aMenu | self inspectionMenu: aMenu ]! !!ReversiCell methodsFor: 'initialize' stamp: 'CameronBierwagen 11/3/2019 19:55'!initialize	super initialize.	state := $_.	neighbors := Array new: 8.! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 19:55'!initialize	super initialize.	cells := Array2D new: 8.	cells atAllPut: ReversiCell new.		! !----SNAPSHOT----2019-11-03T19:55:45.581217-08:00 Pharo 8.0 - 64bit (development version, latest) - Reversi.image priorSource: 100!!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:10'!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ & (pieceType = $B | pieceType = $W)) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:11' prior: 33560773!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ & (pieceType = $B | $W)) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:11' prior: 33561076!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ and: [pieceType = $B or: $W]) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:14' prior: 33561367!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ and: [(pieceType = $B) or: [pieceType = $W]]) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:14' prior: 33561663!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ and: [pieceType = $B | $W]) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:15' prior: 33561975!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_ & (pieceType = $B | $W)) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:16' prior: 33562269!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state == $_ & (pieceType == $B | $W)) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:19' prior: 33562560!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(pieceType = $B | $W) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:21' prior: 33562853!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(pieceType = $_) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/3/2019 20:23' prior: 33563129!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_) ifTrue: [ state := pieceType. ^true ].	^false				! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 20:27' prior: 33560467!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :x | 1 to: 8 do: [ :y | cells at: x at: y put: ReversiCell new. ] ].		! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 20:28' prior: 33563671!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :x | 1 to: 8 do: [ :y | cells at: x at: y put: ReversiCell new. ] ].	(cells at: 4 at: 4) placePiece: $W.	(cells at: 5 at: 5) placePiece: $W.	(cells at: 4 at: 5) placePiece: $W.	(cells at: 5 at: 4) placePiece: $W.		! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 20:28' prior: 33563915!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :x | 1 to: 8 do: [ :y | cells at: x at: y put: ReversiCell new. ] ].	(cells at: 4 at: 4) placePiece: $W.	(cells at: 5 at: 5) placePiece: $W.	(cells at: 4 at: 5) placePiece: $B.	(cells at: 5 at: 4) placePiece: $B.		! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:32'!boardAsString	"Convert the game board to a printable string."				String streamContents: [ :stream ]! !!ReversiCell methodsFor: 'accessor' stamp: 'CameronBierwagen 11/3/2019 20:33'!state	^state! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:42' prior: 33564697!boardAsString	"Convert the game board to a printable string."	String streamContents: [ :stream | 		1 to: 8 do: [ :x | 1 to: 8 do: [ :y | stream nextPut: (cells at: x at: y) state.  ] ]	]		"."! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:42' prior: 33565010!boardAsString	"Convert the game board to a printable string."	String streamContents: [ :stream | 		1 to: 8 do: [ :x | 1 to: 8 do: [ :y | stream nextPut: (cells at: x at: y) state.  ] ]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:44' prior: 33565322!boardAsString	"Convert the game board to a printable string."	String streamContents: [ :stream | 		1 to: 8 do: [ :x | 1 to: 8 do: [ :y | stream nextPut: (cells at: x at: y) state  ] ]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:44' prior: 33565628!boardAsString	"Convert the game board to a printable string."	String streamContents: [ :stream | 		1 to: 8 do: [ :x | 1 to: 8 do: [ :y | stream nextPut: (cells at: x at: y) state  ]. stream cr ]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 20:57' prior: 33565933!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		1 to: 8 do: [ :x | 1 to: 8 do: [ :y | stream nextPut: (cells at: x at: y) state  ]. stream cr ]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:05' prior: 33566249!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:08' prior: 33566566!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: (x + 64); space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:08' prior: 33566949!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			"stream nextPut: (x + 64); space."			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:09' prior: 33567368!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: (x + 64) utf8Decoded; space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:13' prior: 33567789!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: Character value: x + 65; space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:13' prior: 33568220!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: (Character value: x + 65); space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:14' prior: 33568654!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '  1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: (Character value: x + 64); space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:14' prior: 33569090!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '   1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :x |			stream nextPut: (Character value: x + 64); space.			1 to: 8 do: [ :y |				stream space; nextPut: (cells at: x at: y) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 21:24' prior: 33564307!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :x | 1 to: 8 do: [ :y | cells at: x at: y put: ReversiCell new. ] ].	(cells at: 4 at: 4) placePiece: $W.	(cells at: 5 at: 5) placePiece: $W.	(cells at: 4 at: 5) placePiece: $B.	(cells at: 5 at: 4) placePiece: $B.	(cells at: 5 at: 8) placePiece: $B.		! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 21:27' prior: 33569949!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :row | 1 to: 8 do: [ :col | cells at: row at: col put: ReversiCell new. ] ].	(cells at: 4 at: 4) placePiece: $W.	(cells at: 5 at: 5) placePiece: $W.	(cells at: 4 at: 5) placePiece: $B.	(cells at: 5 at: 4) placePiece: $B.		! !!ReversiBoard methodsFor: 'public - string reading' stamp: 'CameronBierwagen 11/3/2019 21:27' prior: 33569526!boardAsString	"Convert the game board to a printable string."	^String streamContents: [ :stream | 		stream nextPutAll: '   1 2 3 4 5 6 7 8'; cr.				1 to: 8 do: [ :row |			stream nextPut: (Character value: row + 64); space.			1 to: 8 do: [ :col |				stream space; nextPut: (cells at: row at: col) state			]. stream cr		]	]! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 21:30'!setCellNeighbors	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			cells at: row at: col.			]		].! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/3/2019 21:30' prior: 33571209!setCellNeighbors	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			cells at: row at: col.		]	].! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 21:54'!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := 		col := col + 1.! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 21:58' prior: 33571807!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array		with: [ col := col + 1 ] "E"		with: [ row := row - 1 ] "NE"		with: [ col := col - 1 ] "N"		with: [ col := col - 1 ] "NW"		with: [ row := row + 1 ] "W"		with: [ row := row + 1 ] "SW"		with: [ col := col + 1 ] "S"		with: [ col := col + 1 ] "SE"		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 21:58' prior: 33572304!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array		with: [ col := col + 1 ] "E"		with: [ row := row - 1 ] "NE"		with: [ col := col - 1 ] "N"		with: [ col := col - 1 ] "NW"		with: [ row := row + 1 ] "W"		with: [ row := row + 1 ] "SW"		with: [ col := col + 1 ] "S"		with: [ col := col + 1 ]. "SE"		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:02' prior: 33573043!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array withAll: #(	[ col := col + 1 ]	[ row := row - 1 ]	[ col := col - 1 ]	[ col := col - 1 ]	[ row := row + 1 ]	[ row := row + 1 ]	[ col := col + 1 ]	[ col := col + 1 ])	! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:08' prior: 33573783!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array withAll: #(	[ col := col + 1 ]	[ row := row - 1 ]	[ col := col - 1 ]	[ col := col - 1 ]	[ row := row + 1 ]	[ row := row + 1 ]	[ col := col + 1 ]	[ col := col + 1 ]).	1 to: 8 do: [ :direction |		operations at: direction.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			]		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:09' prior: 33574441!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations|	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array withAll: #(	[ col := col + 1 ]	[ row := row - 1 ]	[ col := col - 1 ]	[ col := col - 1 ]	[ row := row + 1 ]	[ row := row + 1 ]	[ col := col + 1 ]	[ col := col + 1 ]).	1 to: 8 do: [ :direction |		operations at: direction.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:11' prior: 33575344!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array withAll: #(	[ col := col + 1 ]	[ row := row - 1 ]	[ col := col - 1 ]	[ col := col - 1 ]	[ row := row + 1 ]	[ row := row + 1 ]	[ col := col + 1 ]	[ col := col + 1 ]).	1 to: 8 do: [ :direction |		operations at: direction.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:17' prior: 33576259!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array withAll: #(	[ col := col + 1 ]	[ row := row - 1 ]	[ col := col - 1 ]	[ col := col - 1 ]	[ row := row + 1 ]	[ row := row + 1 ]	[ col := col + 1 ]	[ col := col + 1 ]).	1 to: 8 do: [ :direction |		(operations at: direction) value: nil.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:25' prior: 33577175!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8;	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value: nil.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:27' prior: 33578104!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value: nil.		"If we fall outside of these bounds, the neighbor will be nil."		(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:27' prior: 33579159!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction		"If we fall outside of these bounds, the neighbor will be nil."		 End of statement list encountered ->(row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:27' prior: 33580226!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.		"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:29' prior: 33581316!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.		Transcript show: row; space; column.		"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/3/2019 22:29' prior: 33582371!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.		Transcript show: row.		Transcript show: col.		"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/5/2019 18:30' prior: 33583465!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ Transcript show: 'Works' ]; "E"	at: 2 put: [ Transcript show: 'Works' ]; "NE"	at: 3 put: [ Transcript show: 'Works' ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.				"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/5/2019 18:32' prior: 33584568!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.				"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^operations		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/5/2019 18:32' prior: 33585656!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		operations at: direction.				"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/5/2019 18:34' prior: 33586715!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value.				"If we fall outside of these bounds, the neighbor will be nil."		 (row > 0 & row < 9 & col > 0 & col < 9) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/5/2019 18:37'!neighbors: anArray				neighbors := anArray! !!ReversiCell methodsFor: 'setter' stamp: 'CameronBierwagen 11/5/2019 18:39'!setNeighbors: anArray				neighbors := anArray! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/5/2019 18:39' prior: 33571513!setCellNeighbors	"For each cell, set its neighbors field to enable easy traversing."				1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell setNeighbors: (cell findCellNeighbors: row at: col).		]	].! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/5/2019 18:40' prior: 33570378!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :row | 1 to: 8 do: [ :col | cells at: row at: col put: ReversiCell new. ] ].	(cells at: 4 at: 4) placePiece: $W.	(cells at: 5 at: 5) placePiece: $W.	(cells at: 4 at: 5) placePiece: $B.	(cells at: 5 at: 4) placePiece: $B.	self setCellNeighbors.		! !!ReversiCell methodsFor: 'accessor' stamp: 'CameronBierwagen 11/6/2019 21:49'!isEmpty	^ (state = $_)! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:49'!checkForLegalMoves	"Scan all cells until one with a legal move is found (in which case return true),	or no legal moves are found (in which case return false)."		1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell  setNeighbors: (cell findCellNeighbors: row at: col).		]	].		^ false				! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:51' prior: 33589949!checkForLegalMoves	"Scan all cells until one with a legal move is found (in which case return true),	or no legal moves are found (in which case return false)."		1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell isEmpty ifTrue: [				cell checkForLegalMoves ifTrue: [^ true]			]		]	].		^ false				! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:52'!checkForLegalMovesBlack	"Scan all cells until one with a legal move is found (in which case return true),	or no legal moves are found (in which case return false)."		1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell isEmpty ifTrue: [				cell checkForLegalMovesBlack ifTrue: [^ true]			]		]	].		^ false				! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:52'!checkForLegalMovesWhite	"Scan all cells until one with a legal move is found (in which case return true),	or no legal moves are found (in which case return false)."		1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell isEmpty ifTrue: [				cell checkForLegalMovesWhite ifTrue: [^ true]			]		]	].		^ false				! !ReversiBoard removeSelector: #checkForLegalMoves!!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:58'!checkForLegalMovesBlack	neighbors notNil: [ 		]! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 21:58' prior: 33591785!checkForLegalMovesBlack	neighbors ifNotNil: [ 		]! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 22:13' prior: 33591934!checkForLegalMovesBlack	neighbors ifNotNil: [		| neighbor |		1 to: 8 do: [ :index |			neighbor := neighbors 		]	].^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 22:13' prior: 33592085!checkForLegalMovesBlack	neighbors ifNotNil: [		| neighbor |		1 to: 8 do: [ :index |			neighbor := neighbors at: index.		]	].^ false! !!ReversiCell methodsFor: 'accessor' stamp: 'CameronBierwagen 11/6/2019 22:28'!neighborAtDirection: direction	^ neighbors at: direction! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 22:30'!checkForLegalMoveBlackInDirection: direction	| neighbor nState|	neighbor := neighbors at: direction.		(neighbor state = $W) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		[ neighbor state = $W ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $B)	].		^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 22:31' prior: 33592673!checkForLegalMoveBlackInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		(neighbor state = $W) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		[ neighbor state = $W ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $B)	].		^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/6/2019 22:33' prior: 33592312!checkForLegalMovesBlack	1 to: 8 do: [ :index |		(self checkForLegalMoveBlackInDirection: index) ifTrue: [ ^ true ].	].^ false! !!ReversiCell methodsFor: 'as yet unclassified' stamp: 'CameronBierwagen 11/6/2019 22:35'!checkForLegalMovesWhite	1 to: 8 do: [ :index |		(self checkForLegalMoveWhiteInDirection: index) ifTrue: [ ^ true ].	].^ false! !!ReversiCell methodsFor: 'as yet unclassified' stamp: 'CameronBierwagen 11/6/2019 22:36'!checkForLegalMoveWhiteInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		(neighbor state = $B) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		[ neighbor state = $B ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $W)	].		^ false! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 16:18'!placeWhite				| neighborsAffected |	neighborsAffected := 0.	! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:28'!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		(nextPiece makeWhiteInDirection: direction)			] ! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:29'!setState: newState	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					state := newState! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:29' prior: 33595153!setState: newState				state := newState! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:29'!state: newState				state := newState! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:29' prior: 33595401!setState: newState				state := newState! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:35' prior: 33594755!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W		]			] ! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:35' prior: 33595820!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		]			] ! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:38' prior: 33596372!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	^(nextPiece state = $W)! !!ReversiCell methodsFor: 'as yet unclassified' stamp: 'CameronBierwagen 11/7/2019 16:40'!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	^(nextPiece state = $B)! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 16:41' prior: 33563400!placePiece: pieceType	"Place a white or black piece if the cell is empty. Returns true if successful."	(state = $_) ifTrue: [ state := pieceType. ^true ].	^false! !ReversiCell removeSelector: #state:!!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 16:44' prior: 33589436!initialize	super initialize.	cells := Array2D new: 8.	1 to: 8 do: [ :row | 1 to: 8 do: [ :col | cells at: row at: col put: ReversiCell new. ] ].	(cells at: 4 at: 4) setState: $W.	(cells at: 5 at: 5) setState: $W.	(cells at: 4 at: 5) setState: $B.	(cells at: 5 at: 4) setState: $B.	self setCellNeighbors.		! !ReversiCell removeSelector: #placeWhite!!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:48'!placeWhite	! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:49' prior: 33598927!placeWhite				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeWhiteInDirection: direction) or: success.		]	].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:51' prior: 33598185!placePiece: pieceColor	"Attempt to place a white or black piece if the cell is empty.	Returns true if successful.	Returns false if no legal moves exist in the desired space, or if the supplied color is invalid."		(pieceColor = $W) ifTrue: [ ^ self placeWhite ].	(pieceColor = $B) ifTrue: [ ^ self placeBlack ].	^ false! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:52'!placeBlack				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeBlackInDirection: direction) or: success.		]	].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:53' prior: 33599726!placeBlack				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeBlackInDirection: direction) or: success.		]	].	success ifTrue: [ state := $B ].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 18:53' prior: 33599037!placeWhite				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeWhiteInDirection: direction) or: success.		]	].	success ifTrue: [ state := $W ].	^success! !Object subclass: #ReversiGame	instanceVariableNames: 'board turn state'	classVariableNames: ''	package: 'Reversi'!Object subclass: #ReversiGame	instanceVariableNames: 'board turn active'	classVariableNames: ''	package: 'Reversi'!!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 18:56' prior: 33559345!initialize			board := ReversiBoard new.	active := true.	turn := $B.! !Object subclass: #ReversiGame	instanceVariableNames: 'board turn'	classVariableNames: ''	package: 'Reversi'!!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 18:57' prior: 33600881!initialize			board := ReversiBoard new.	turn := $B.! !!ReversiCell methodsFor: 'initialize' stamp: 'CameronBierwagen 11/7/2019 18:58' prior: 33560311!initialize	super initialize.	state := $_.! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 18:59' prior: 33601164!initialize			super initialize.	board := ReversiBoard new.	turn := $B.! !!ReversiBoard methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 19:01' prior: 33589084!setCellNeighbors	"For each cell, set its neighbors field to enable easy traversing."				1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			cell setNeighbors: (self findCellNeighbors: row at: col).		]	].! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/7/2019 19:02' prior: 33587773!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value.				"If we fall outside of these bounds, the neighbor will be nil."		 ((row > 0) and: [(row < 9) and: [col > 0]]  and: [col < 9]) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/7/2019 19:04' prior: 33601994!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value.				"If we fall outside of these bounds, the neighbor will be nil."		 ((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'finding/searching' stamp: 'CameronBierwagen 11/7/2019 19:04' prior: 33603080!findCellNeighbors: rowNumber at: columnNumber	"Get the neighbors of a cell so that the information can then be stored in the cell itself."		| row col neighbors operations |	row := rowNumber.	col := columnNumber.	neighbors := Array new: 8.		"This use of blocks might be kind of hacky, but I think it's cool. Start to the east and move around counter-clockwise."	operations := Array new: 8.	operations	at: 1 put: [ col := col + 1 ]; "E"	at: 2 put: [ row := row - 1 ]; "NE"	at: 3 put: [ col := col - 1 ]; "N"	at: 4 put: [ col := col - 1 ]; "NW"	at: 5 put: [ row := row + 1 ]; "W"	at: 6 put: [ row := row + 1 ]; "SW"	at: 7 put: [ col := col + 1 ]; "S"	at: 8 put: [ col := col + 1 ]. "SE"	1 to: 8 do: [ :direction |		(operations at: direction) value.				"If we fall outside of these bounds, the neighbor will be nil."		 ((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			neighbors at: direction put: (cells at: row at: col)		]			].^neighbors		! !!ReversiBoard methodsFor: 'accessing' stamp: 'CameronBierwagen 11/7/2019 19:15'!getCellAt: row at: col	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					^ cells at: row at: col! !!ReversiBoard methodsFor: 'accessing' stamp: 'CameronBierwagen 11/7/2019 19:16' prior: 33605244!getCellAt: row at: col	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					^ (cells at: row at: col)! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:24' prior: 33597565!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	^(nextPiece state = $B)! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 19:26' prior: 33600008!placeBlack				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeBlackInDirection: direction) or: success.		]	].	success ifTrue: [ self setState: $B ].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 19:32' prior: 33606371!placeBlack				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeBlackInDirection: direction) or: success.		]	].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 19:33' prior: 33600324!placeWhite				| success |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			success := (self makeWhiteInDirection: direction) or: success.		]	].	^success! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:38' prior: 33605758!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			self setState: $B.			"Keep cascading"			^ true.		].		^ false.			].	^(nextPiece state = $B)! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:46' prior: 33607264!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			self setState: $B.			"Keep cascading"			^ true.		].		^ false.			].	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		self setState: $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:47' prior: 33596956!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			self setState: $W.			"Keep cascading"			^ true.		].		^ false.			].	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		self setState: $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:57' prior: 33608660!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		state := $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 19:57' prior: 33607890!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		state := $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:01' prior: 33609430!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	"Recursive Case"	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		state := $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:01' prior: 33610188!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	"Recursive Case"	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		state := $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:03' prior: 33610946!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	"Recursive Case"	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		state := $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:03' prior: 33611735!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	"Recursive Case"	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		state := $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:24' prior: 33613345!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	(nextPiece state = $_) ifTrue: [ ^ false ].	"Recursive Case"	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		state := $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:25' prior: 33612524!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	(nextPiece state = $_) ifTrue: [ ^ false ].	"Recursive Case"	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		state := $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:31' prior: 33614166!makeBlackInDirection: direction	"Recursively attempts to flip over a line of white pieces terminated by a black piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	"Recursive Case"	(nextPiece state = $W) ifTrue: [		"This could still be a valid move."		(nextPiece makeBlackInDirection: direction) ifTrue: [			"We've confirmed that the final piece is black, so flip ourselves."			state := $B.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $B) ifTrue: [ 		"We've confirmed that the final piece is black, so flip ourselves."		state := $B.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'changing state' stamp: 'CameronBierwagen 11/7/2019 20:31' prior: 33615032!makeWhiteInDirection: direction	"Recursively attempts to flip over a line of black pieces terminated by a white piece.	Return true if successful, false if not."				| nextPiece |	nextPiece := (neighbors at: direction).	nextPiece ifNil: [  ^ false ].	"Recursive Case"	(nextPiece state = $B) ifTrue: [		"This could still be a valid move."		(nextPiece makeWhiteInDirection: direction) ifTrue: [			"We've confirmed that the final piece is white, so flip ourselves."			state := $W.			"Keep cascading"			^ true.		].		^ false.			].	"Base Case"	(nextPiece state = $W) ifTrue: [ 		"We've confirmed that the final piece is white, so flip ourselves."		state := $W.		"Keep cascading"		^ true.	].	^ false.! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 20:34' prior: 33606693!placeBlack				| success neighbor |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			neighbor := (neighbors at: direction).			neighbor ifNotNil: [				(neighbor state = $W) ifTrue: [					success := (self makeBlackInDirection: direction) or: success.				]			]		]	].	^success! !!ReversiCell methodsFor: 'putting' stamp: 'CameronBierwagen 11/7/2019 20:35' prior: 33606975!placeWhite				| success neighbor |	success := false.	(state = $_) ifTrue: [ 		1 to: 8 do: [ :direction |			neighbor := (neighbors at: direction).			neighbor ifNotNil: [				(neighbor state = $B) ifTrue: [					success := (self makeWhiteInDirection: direction) or: success.				]			]		]	].	^success! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 20:51' prior: 33594122!checkForLegalMoveWhiteInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		neighbor ifNil: [ ^ false ].	(neighbor state = $B) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		[ neighbor state = $B ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $W)	].		^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 20:52' prior: 33593178!checkForLegalMoveBlackInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		neighbor ifNil: [ ^ false ].	(neighbor state = $W) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		[ neighbor state = $W ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $B)	].		^ false! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:06'!nextTurn	"Print instructions for the player whose turn it is."		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:07'!endGame	"Tally the score and declare a winner"	! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:33' prior: 33619385!nextTurn	"Print instructions for the player whose turn it is."	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: ' Test ' title: (turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn'.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:33' prior: 33619681!nextTurn	"Print instructions for the player whose turn it is."	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:37' prior: 33620143!nextTurn	"Print instructions for the player whose turn it is."	| success |	success := false.	success whileFalse: [ ].	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:39' prior: 33620601!nextTurn	"Print instructions for the player whose turn it is."	| success |	success := false.	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').	success whileFalse: [		UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'That was not a valid move. Please try again.'; cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').	].			! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 21:47'!requestInput	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 21:48'!requestInputWithError	UIManager default request:	(String streamContents: [ :stream | 		stream nextPutAll: (board boardAsString); cr;		nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])	initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 21:48' prior: 33622379!requestInputWithError	UIManager default request:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'That was not a valid move. Please try again.'; cr;			nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])		initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 21:48' prior: 33621986!requestInput	UIManager default request:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])		initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn').! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:49' prior: 33621117!nextTurn	"Print instructions for the player whose turn it is."	| input success |	success := false.				"The first attempt didn't work."	success whileFalse: [			].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:50' prior: 33623693!nextTurn	"Print instructions for the player whose turn it is."	| input success |	success := false.		input := self requestInput.				"The first attempt didn't work."	success whileFalse: [			].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:50' prior: 33623968!nextTurn	"Print instructions for the player whose turn it is."	| input success |	success := false.		input := self requestInput.			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:50' prior: 33624274!nextTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:54' prior: 33624614!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) value) - 64.	col := (input at: 2).			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:56' prior: 33624954!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2).			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:58' prior: 33625362!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2).		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 21:59' prior: 33625774!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2).		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2).			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 22:01' prior: 33623286!requestInput	^ (UIManager default request:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])		initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn')).! !!ReversiGame methodsFor: 'user requests' stamp: 'CameronBierwagen 11/7/2019 22:01' prior: 33622797!requestInputWithError	^ (UIManager default request:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'That was not a valid move. Please try again.'; cr;			nextPutAll: 'Enter the cell in which to place your next piece (for example, "I9").' ])		initialAnswer: '' title: ((turn = $B) ifTrue: 'Black''s Turn' ifFalse: 'White''s turn')).! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:03' prior: 33626326!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	success whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2).			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:03' prior: 33627999!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2).			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:05' prior: 33628772!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:06' prior: 33629549!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := 'I9'.	input := self requestInput.		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:07' prior: 33630336!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	input ifNil: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:07' prior: 33631139!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	input ifNil: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:08' prior: 33631959!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	input ifNil: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:09' prior: 33632813!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	input ifNil: [ input := 'I9' ].	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:11' prior: 33633715!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self delete ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:13' prior: 33634664!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	"input ifNil: [ self delete ]."	"If input doesn't meet requirements"	"((input size) < 2) ifTrue: [ input := 'I9' ]."		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:13' prior: 33635680!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self delete ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].			! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:17' prior: 33636700!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:18' prior: 33637716!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ input := 'I9' ].		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.		Transcript show: row; space; show: col.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:20' prior: 33638746!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asInteger.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		"If cancel button is clicked"		input ifNil: [ self endGame. ^false ].		"If input doesn't meet requirements"		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.		Transcript show: row; space; show: col.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:20' prior: 33639818!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := ((input at: 1) codePoint) - 64.	col := (input at: 2) asNumber.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		"If cancel button is clicked"		input ifNil: [ self endGame. ^false ].		"If input doesn't meet requirements"		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.		Transcript show: row; space; show: col.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:23' prior: 33640968!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := (((input at: 1) translateToUppercase) codePoint) - 64.	col := ((input at: 2) codePoint) - 48.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		"If cancel button is clicked"		input ifNil: [ self endGame. ^false ].		"If input doesn't meet requirements"		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.		Transcript show: row; space; show: col.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:24' prior: 33642117!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := (((input at: 1) asUppercase) codePoint) - 64.	col := ((input at: 2) codePoint) - 48.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		"If cancel button is clicked"		input ifNil: [ self endGame. ^false ].		"If input doesn't meet requirements"		((input size) < 2) ifTrue: [ input := 'I9' ].				row := ((input at: 1) codePoint) - 64.		col := (input at: 2) asInteger.		Transcript show: row; space; show: col.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:26' prior: 33643297!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := (((input at: 1) asUppercase) codePoint) - 64.	col := ((input at: 2) codePoint) - 48.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		"If cancel button is clicked"		input ifNil: [ self endGame. ^false ].		"If input doesn't meet requirements"		((input size) < 2) ifTrue: [ input := 'I9' ].				row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.			((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [			success := (board getCellAt: row at: col) placePiece: turn.		].	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:30'!moveFromInput: input	| row col |	row := 0.	col := 0.		"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ (board getCellAt: row at: col) placePiece: turn.	].! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:31' prior: 33645602!moveFromInput: input	| row col |	row := 0.	col := 0.		"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ ((board getCellAt: row at: col) placePiece: turn).	].! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:31' prior: 33646134!moveFromInput: input	| row col |	row := 0.	col := 0.		"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ (board getCellAt: row at: col) placePiece: turn.	].! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:31' prior: 33646668!moveFromInput: input	| row col |	row := 0.	col := 0.		"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ ((board getCellAt: row at: col) placePiece: turn).	].! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:31' prior: 33647200!moveFromInput: input	| row col |	row := 0.	col := 0.		"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ ((board getCellAt: row at: col) placePiece: turn).	].^false! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:32' prior: 33644468!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	"If cancel button is clicked"	input ifNil: [ self endGame. ^false ].	"If input doesn't meet requirements"	((input size) < 2) ifTrue: [ input := 'I9' ].		row := (((input at: 1) asUppercase) codePoint) - 64.	col := ((input at: 2) codePoint) - 48.		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		success := (board getCellAt: row at: col) placePiece: turn.	].			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		success := (self moveFromInput: input)	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:32' prior: 33648276!nextTurn	"Print instructions for the player whose turn it is."	| success input row col|	success := false.		input := self requestInput.	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		success := (self moveFromInput: input)	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:32' prior: 33649065!nextTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		success := (self moveFromInput: input)	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:33' prior: 33647734!moveFromInput: input	| row col |	row := 0.	col := 0.		"Make sure input meets length requirement"	((input size) = 2) ifTrue: [ 		row := (((input at: 1) asUppercase) codePoint) - 64.		col := ((input at: 2) codePoint) - 48.	].		((row > 0) and: [(row < 9) and: [(col > 0) and: [col < 9]]]) ifTrue: [		^ ((board getCellAt: row at: col) placePiece: turn).	].^false! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:34' prior: 33649503!nextTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.	input ifNil: [ self endGame. ^false ].	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ self endGame. ^false ].		success := (self moveFromInput: input)	].^true.		! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 22:37'!checkForLegalMoves: color				(color = $B) ifTrue: [ ^(self checkForLegalMovesBlack) ].	(color = $W) ifTrue: [ ^(self checkForLegalMovesWhite) ].! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 22:37' prior: 33650903!checkForLegalMoves: color				(color = $B) ifTrue: [ ^(self checkForLegalMovesBlack) ].	(color = $W) ifTrue: [ ^(self checkForLegalMovesWhite) ].	^ false.! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:39'!takeTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.	input ifNil: [ self endGame. ^false ].	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ self endGame. ^false ].		success := (self moveFromInput: input)	].^true.		! !ReversiGame removeSelector: #nextTurn!!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:41'!nextTurn	"Changes the turn to the next player"	(turn = $B) ifTrue: [ turn = $W ] ifFalse: [ turn = $B ].! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 22:41' prior: 33651925!nextTurn	"Changes the turn to the next player"	(turn = $B) ifTrue: [ turn := $W ] ifFalse: [ turn := $B ].! !Object subclass: #ReversiGame	instanceVariableNames: 'board turn active'	classVariableNames: ''	package: 'Reversi'!!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 22:43' prior: 33601461!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.		[ active ] whileTrue: [ 		self takeTurn.		self nextTurn.		active := (board checkForLegalMoves: turn).	]! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 22:46' prior: 33618874!checkForLegalMoveBlackInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		neighbor ifNil: [ ^ false ].	(neighbor state = $W) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		neighbor ifNil: [ ^ false ].		[ neighbor state = $W ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.		].		^ (neighbor state = $B)	].		^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 22:47' prior: 33652756!checkForLegalMoveBlackInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		neighbor ifNil: [ ^ false ].	(neighbor state = $W) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		neighbor ifNil: [ ^ false ].		[ neighbor state = $W ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.			neighbor ifNil: [ ^ false ].		].		^ (neighbor state = $B)	].		^ false! !!ReversiCell methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 22:47' prior: 33618346!checkForLegalMoveWhiteInDirection: direction	| neighbor|	neighbor := neighbors at: direction.		neighbor ifNil: [ ^ false ].	(neighbor state = $B) ifTrue: [ "The first one must be the opposite color for this to be a legal move."		neighbor := neighbor neighborAtDirection: direction.		neighbor ifNil: [ ^ false ].		[ neighbor state = $B ] whileTrue: [ 			neighbor := neighbor neighborAtDirection: direction.			neighbor ifNil: [ ^ false ].		].		^ (neighbor state = $W)	].		^ false! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 23:03'!getScores	| score |		"First index is Black, second is White"	score := Array with: 0 with: 0.				1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			(cell = $B) ifTrue: [ score at: 1 put: ((score at: 1) + 1)].			(cell = $W) ifTrue: [ score at: 2 put: ((score at: 2) + 1)].		]	]! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/7/2019 23:03' prior: 33654482!getScores	| scores |		"First index is Black, second is White"	scores := Array with: 0 with: 0.				1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			(cell = $B) ifTrue: [ scores at: 1 put: ((scores at: 1) + 1)].			(cell = $W) ifTrue: [ scores at: 2 put: ((scores at: 2) + 1)].		]	].^ scores! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 23:11' prior: 33619534!endGame	"Tally the score and declare a winner"	| scores message |	scores := board getScores.		message := 'Black wins!!'.		((scores at: 1) = (scores at: 2)) ifTrue: [ message := 'The game is a draw.' ] ifFalse: [ 		((scores at: 1) < (scores at: 2)) ifTrue: [ message := 'White wins!!' ]	].	! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 23:16' prior: 33655354!endGame	"Tally the score and declare a winner"	| scores message |	scores := board getScores.		message := 'Black wins!!'.		((scores at: 1) = (scores at: 2)) ifTrue: [ message := 'The game is a draw.' ] ifFalse: [ 		((scores at: 1) < (scores at: 2)) ifTrue: [ message := 'White wins!!' ]	].	(UIManager default message:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'The final score is:'; cr;			nextPutAll: 'Black: '; nextPutAll: (scores at: 1); nextPutAll: ' points.'; cr;			nextPutAll: 'White: '; nextPutAll: (scores at: 2); nextPutAll: ' points.'; cr;			nextPutAll: message.		])		title: 'Game Over!!').	! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 23:17' prior: 33655751!endGame	"Tally the score and declare a winner"	| scores message |	scores := board getScores.		message := 'Black wins!!'.		((scores at: 1) = (scores at: 2)) ifTrue: [ message := 'The game is a draw.' ] ifFalse: [ 		((scores at: 1) < (scores at: 2)) ifTrue: [ message := 'White wins!!' ]	].	(UIManager default message:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'The final score is:'; cr;			nextPutAll: 'Black: '; nextPutAll: (scores at: 1) asString; nextPutAll: ' points.'; cr;			nextPutAll: 'White: '; nextPutAll: (scores at: 2) asString; nextPutAll: ' points.'; cr;			nextPutAll: message.		])		title: 'Game Over!!').	! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/7/2019 23:18' prior: 33656526!endGame	"Tally the score and declare a winner"	| scores message |		active := false.		scores := board getScores.		message := 'Black wins!!'.		((scores at: 1) = (scores at: 2)) ifTrue: [ message := 'The game is a draw.' ] ifFalse: [ 		((scores at: 1) < (scores at: 2)) ifTrue: [ message := 'White wins!!' ]	].	(UIManager default message:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'The final score is:'; cr;			nextPutAll: 'Black: '; nextPutAll: (scores at: 1) asString; nextPutAll: ' points.'; cr;			nextPutAll: 'White: '; nextPutAll: (scores at: 2) asString; nextPutAll: ' points.'; cr;			nextPutAll: message.		])		title: 'Game Over!!').	! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/7/2019 23:20' prior: 33652457!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.		[ active ] whileTrue: [ 		self takeTurn.		self nextTurn.		active := (active and: [board checkForLegalMoves: turn]).	]! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/8/2019 13:31' prior: 33658136!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.		[ active ] whileTrue: [ 		self takeTurn.		self nextTurn.		active := (active and: [board checkForLegalMoves: turn]).	].	self endGame.! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:33' prior: 33651389!takeTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.	input ifNil: [ ^false ].	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ ^false ].		success := (self moveFromInput: input)	].^true.		! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:35' prior: 33658779!takeTurn	"Print instructions for the player whose turn it is."	| success input |	success := false.		input := self requestInput.	input ifNil: [ ^false ].	success := (self moveFromInput: input).			"The first attempt didn't work."	[ success ] whileFalse: [		input := self requestInputWithError.		input ifNil: [ ^false ].		success := (self moveFromInput: input)	].	self nextTurn.	^true.		! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/8/2019 13:36' prior: 33658450!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.		[ active ] whileTrue: [ 				active := ((self takeTurn) and: [board checkForLegalMoves: turn]).	].	self endGame.! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:37' prior: 33657319!endGame	"Tally the score and declare a winner"	| scores message |		"This has likely already been made false, but let's be safe."	active := false.		scores := board getScores.		message := 'Black wins!!'.		((scores at: 1) = (scores at: 2)) ifTrue: [ message := 'The game is a draw.' ] ifFalse: [ 		((scores at: 1) < (scores at: 2)) ifTrue: [ message := 'White wins!!' ]	].	(UIManager default message:		(String streamContents: [ :stream | 			stream nextPutAll: (board boardAsString); cr;			nextPutAll: 'The final score is:'; cr;			nextPutAll: 'Black: '; nextPutAll: (scores at: 1) asString; nextPutAll: ' points.'; cr;			nextPutAll: 'White: '; nextPutAll: (scores at: 2) asString; nextPutAll: ' points.'; cr;			nextPutAll: message.		])		title: 'Game Over!!').	! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:43'!start	[ active ] whileTrue: [ 				active := ((self takeTurn) and: [board checkForLegalMoves: turn]).	].	self endGame.! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/8/2019 13:43' prior: 33659766!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.		self start.! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/8/2019 13:43' prior: 33661156!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := true.! !!ReversiGame methodsFor: 'initalize' stamp: 'CameronBierwagen 11/8/2019 13:43' prior: 33661360!initialize			super initialize.	board := ReversiBoard new.	turn := $B.	active := false.! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:44' prior: 33660934!start	active := true.		[ active ] whileTrue: [ 				active := ((self takeTurn) and: [board checkForLegalMoves: turn]).	].	self endGame.! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:44' prior: 33661737!start	active := true.		[ active ] whileTrue: [ 				active := ((self takeTurn) and: [board checkForLegalMoves: turn]).		Transcript show: (board getScores).	].	self endGame.! !!ReversiBoard methodsFor: 'checking' stamp: 'CameronBierwagen 11/8/2019 13:45' prior: 33654911!getScores	| scores |		"First index is Black, second is White"	scores := Array with: 0 with: 0.				1 to: 8 do: [ :row |		1 to: 8 do: [ :col |			| cell |			cell := (cells at: row at: col).			(cell state = $B) ifTrue: [ scores at: 1 put: ((scores at: 1) + 1)].			(cell state = $W) ifTrue: [ scores at: 2 put: ((scores at: 2) + 1)].		]	].^ scores! !!ReversiGame methodsFor: 'playing' stamp: 'CameronBierwagen 11/8/2019 13:46' prior: 33661976!start	active := true.		[ active ] whileTrue: [ 				active := ((self takeTurn) and: [board checkForLegalMoves: turn]).	].	self endGame.! !!IceTipRepositoriesBrowser methodsFor: 'initialization' stamp: 'AutoDeprecationRefactoring 11/8/2019 13:54' prior: 30903201!initializeRepositoryList	repositoryList widget		beResizable;		addColumn:			(IceTipTableColumn new				id: 'Name';				action: #descriptionWithDecoration;				width: 200;				yourself);		addColumn:			(IceTipTableColumn new				id: 'Status';				action: #status;				width: 150;				yourself);		addColumn:			(IceTipTableColumn new				id: 'Branch';				action: #branchName;				yourself);		dataSource: self newRepositoriesDataSource;		selectIndex: 1;		enableFilter: IceTipRepositoryFilter;		explicitFunction! !!IceTipRepairRepositoryDialog methodsFor: 'private' stamp: 'AutoDeprecationRefactoring 11/8/2019 13:54' prior: 30897776!selectionChanged: ann	selectedOption := ann newSelectedIndexes		ifNotEmpty:			[ :indexes | self optionsList widget dataSource elementAt: indexes first ]		ifEmpty: [ nil ].	self refreshDetailPanel! !!IceTipOptionDialog methodsFor: 'private' stamp: 'AutoDeprecationRefactoring 11/8/2019 13:58' prior: 30824694!selectFirst	typeList widget selectIndex: 1.	self basicSelectionChanged: self allTypes first! !!IceTipOptionDialog methodsFor: 'private' stamp: 'AutoDeprecationRefactoring 11/8/2019 13:58' prior: 30822077!selectionChanged: ann	self		basicSelectionChanged:			(ann newSelectedIndexes				ifNotEmpty:					[ :indexes | self typeList widget dataSource realElementAt: indexes first ]				ifEmpty: [ nil ])! !----QUIT----2019-11-08T14:32:23.707456-08:00 Pharo 8.0 - 64bit (development version, latest) - Reversi.image priorSource: 6131!----SNAPSHOT----2019-11-08T14:35:08.507642-08:00 reversi-smalltalk.image priorSource: 109914!----QUIT----2019-11-08T14:35:10.666429-08:00 reversi-smalltalk.image priorSource: 110043!----QUIT----2019-11-08T14:35:57.362062-08:00 reversi-smalltalk.image priorSource: 110138!----QUIT----2019-11-08T14:36:34.296109-08:00 reversi-smalltalk.image priorSource: 110229!----QUIT/NOSAVE----2019-11-08T14:36:43.432002-08:00 reversi-smalltalk.image priorSource: 110320!